The file system lab asks you to equip the Xv6 kernel to support large files and symbolic links

Large Files
The Xv6 file size supports 268 blocks. This limit comes from the fact that Xv6 inode supports 12 direct pointers and 1 indirect pointer 
ie 12 + 256. So, to support even bigger files double indirect pointers are added to xv6 inode.

So to acheive this, the bmap() in fs.c should be modified. bmap() is called both when reading and writing a file. When writing, 
bmap() allocates new blocks as needed to hold the file content, as well as allocating indirect block if needed. Currently the first 
12 elements of ip->addrs[] is the direct blocks, the 13th is the single indirect block. After modification the first 11 elements 
of ip->addrs[] are the direct blocks, the 12th is the single indirect block and the thriteenth the double indirect blocks. After this 
the itruc() in fs.c should also be modified to support double indirect blocks. The itrunc() is called when truncating the file to zero, 
that is freeing all the blocks currently in the possession of the inode passed to it. 

Symbolic Links
Symbolic links refers to the linked file by pathname. When symbolic link is opened, the kernel follows the link to the referred 
file. First a new systemcall number is created for symlink by adding entries to user/usys.pl, user/user.h. Then a new file type 
T_SYMLINK is added to kenel/stat.h to represent symbolic link. A new kernel flag O_NOFOLLOW that can be used with open systemcall 
is created tell no need to follow symbolic link. Then the actual system call symlink(target,path) is implemented. Then open system 
call is modified to handle file of type T_SYMLINK and when O_NOFOLLOW flag is used for opening symbolic file(NO need to follow the 
path just opens symbolic file).The symbolic link implementation is such that the symbolic link recurses to a depth of 10 links,
more than that then open systemcall fails.
