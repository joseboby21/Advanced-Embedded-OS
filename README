The Xv6 kernel before the lab does not support lazy allocation. Therefore whenever a process asks 
for heap memory using sbrk() system call. sbrk() allocates physical memory and maps it into the 
process virtual address space. Some programs ask for a large amount of memory but never use most 
of it. This is where lazy allocation will help. Through lazy allocation no physical memory is 
allocated through sbrk(), but remembers which addresses are allocated. So when a process first tries 
to use any of these lazily allocated addresses, a page fault is generated, which the kernel handles 
by allocating physical memory.


A function for lazy allocation is written. So whenever a page fault occurs this function is called. 
The function compares the faulting address with the process memory boundary. If it is greater than 
boundary, the process is killed. Then checks whether the address is below stack then also the process 
is killed. If these two cases are not met, then the address is a valid address of the process. Then 
create a new page and map that page to the faulting address. The unmapping function of xv6 is also 
modified to not panic when freeing pages that have not been mapped. Finally copyin and copyout are 
modified so when we copy from kernel to a virtual address or virtual address to kernel, first we 
check whether the destination address is lazily allocated, if lazily allocated  call lazy allocation 
function before copying.
